<?xml version = "1.0"?>
<trigger version="2">

<Conditions>
	<Condition name="$$22289$$Always">
		<Expression>true</Expression>
	</Condition>

</Conditions>

<Effects>
	<Effect name="$$22355$$SetIdleProcessing">
    	<Param name="IdleProc" dispName="$$22356$$Process Idle:" varType="bool">true</Param>
    	<Command>trSetUnitIdleProcessing(%IdleProc%);</Command>
	</Effect>

<Effect name=" _C0 Trigger Loader intro">
<Command>xsDisableSelf();}}</Command>
<Command>const float PI = 3.141592;</Command>

<Command>rule context_change_always</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	xsSetContextPlayer(0);</Command>
<Command>}</Command>

<Command>const int mInt = 0;</Command>
<Command>const int mFloat = 1;</Command>
<Command>const int mString = 2;</Command>
<Command>const int mVector = 3;</Command>
<Command>const int mBool = 4;</Command>

<Command>const int xMetadata = 0; // contains current pointer and database size and numVariables. However, malloc doesn't have metadata so they have to shift down 1</Command>
<Command>const int xDirtyBit = 1;</Command>
<Command>const int xNextBlock = 2;</Command>
<Command>const int xPrevBlock = 3; // for databases, xData is unused and xPrevBlock takes its place</Command>
<Command>const int xData = 3;</Command>
<Command>const int xVarNames = 4; // list of variable names</Command>
<Command>const int xVariables = 5;</Command>

<Command>const int mPointer = 0;</Command>
<Command>const int mCount = 1;</Command>
<Command>const int mNextFree = 2;</Command>
<Command>const int mNewestBlock = 3;</Command>
<Command>const int mCacheHead = 4; // the cache stores items that you want to temporarily remove</Command>
<Command>const int mCacheCount = 5;</Command>
<Command>const int mVariableTypes = 5;</Command>

<Command>const int NEXTFREE = 0; // the very first block contains the next free pointer and nothing else</Command>

<Command>int MALLOC = 0;</Command>
<Command>int ARRAYS = 0;</Command>
<Command>int mNumArrays = 0;</Command>

<Command>bool debugIsOn = true;</Command>

<Command>void debugLog(string msg = "") {</Command>
<Command>	if (debugIsOn) {</Command>
<Command><![CDATA[		trChatSend(0, "<color=1,0,0>" + msg);]]></Command>
<Command>	}</Command>
<Command>}</Command>


<Command>string datatypeName(int data = 0) {</Command>
<Command>	string name = "void";</Command>
<Command><![CDATA[	if (data >= 0 && data <= 4) {]]></Command>
<Command>		name = aiPlanGetUserVariableString(MALLOC,15,data);</Command>
<Command>	}</Command>
<Command>	return(name);</Command>
<Command>}</Command>

<Command>int zNewArray(int type = 0, int size = 1, string name = "") {</Command>
<Command>	int index = mNumArrays;</Command>
<Command>	mNumArrays = mNumArrays + 1;</Command>
<Command>	switch(type)</Command>
<Command>	{</Command>
<Command>		case mInt:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableInt(ARRAYS,index,name,size);</Command>
<Command>		}</Command>
<Command>		case mFloat:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableFloat(ARRAYS,index,name,size);</Command>
<Command>		}</Command>
<Command>		case mString:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableString(ARRAYS,index,name,size);</Command>
<Command>		}</Command>
<Command>		case mVector:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableVector(ARRAYS,index,name,size);</Command>
<Command>		}</Command>
<Command>		case mBool:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableBool(ARRAYS,index,name,size);</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>void zSetInt(int arr = 0, int index = 0, int val = 0) {</Command>
<Command>	aiPlanSetUserVariableInt(ARRAYS, arr, index, val);</Command>
<Command>}</Command>

<Command>void zSetFloat(int arr = 0, int index = 0, float val = 0) {</Command>
<Command>	aiPlanSetUserVariableFloat(ARRAYS, arr, index, val);</Command>
<Command>}</Command>

<Command>void zSetBool(int arr = 0, int index = 0, bool val = false) {</Command>
<Command>	aiPlanSetUserVariableBool(ARRAYS, arr, index, val);</Command>
<Command>}</Command>

<Command>void zSetString(int arr = 0, int index = 0, string val = "") {</Command>
<Command>	aiPlanSetUserVariableString(ARRAYS, arr, index, val);</Command>
<Command>}</Command>

<Command>void zSetVector(int arr = 0, int index = 0, vector val = vector(0,0,0)) {</Command>
<Command>	aiPlanSetUserVariableVector(ARRAYS, arr, index, val);</Command>
<Command>}</Command>

<Command>int zGetInt(int arr = 0, int index = 0) {</Command>
<Command>	return(aiPlanGetUserVariableInt(ARRAYS, arr, index));</Command>
<Command>}</Command>

<Command>float zGetFloat(int arr = 0, int index = 0) {</Command>
<Command>	return(aiPlanGetUserVariableFloat(ARRAYS, arr, index));</Command>
<Command>}</Command>

<Command>bool zGetBool(int arr = 0, int index = 0) {</Command>
<Command>	return(aiPlanGetUserVariableBool(ARRAYS, arr, index));</Command>
<Command>}</Command>

<Command>string zGetString(int arr = 0, int index = 0) {</Command>
<Command>	return(aiPlanGetUserVariableString(ARRAYS, arr, index));</Command>
<Command>}</Command>

<Command>vector zGetVector(int arr = 0, int index = 0) {</Command>
<Command>	return(aiPlanGetUserVariableVector(ARRAYS, arr, index));</Command>
<Command>}</Command>

<Command>bool free(int type = -1, int index = -1) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, type * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		aiPlanSetUserVariableInt(MALLOC, type * 3 + xNextBlock - 1, index,</Command>
<Command>			aiPlanGetUserVariableInt(MALLOC, type * 3 + xNextBlock - 1, NEXTFREE));</Command>
<Command>		aiPlanSetUserVariableBool(MALLOC, type * 3 + xDirtyBit - 1, index, false);</Command>
<Command>		aiPlanSetUserVariableInt(MALLOC, type * 3 + xNextBlock - 1, NEXTFREE, index); // set next free to be the newly added block</Command>
<Command>		success = true;</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int malloc(int type = -1) {</Command>
<Command>	int next = aiPlanGetUserVariableInt(MALLOC, type * 3 + xNextBlock - 1, NEXTFREE);</Command>
<Command>	if (next == 0) {</Command>
<Command>		next = aiPlanGetNumberUserVariableValues(MALLOC,type * 3 + xNextBlock - 1);</Command>
<Command><![CDATA[		for(i=type * 3; < type * 3 + 3) {]]></Command>
<Command>			aiPlanSetNumberUserVariableValues(MALLOC,i,next + 1, false); // resizing seems to be a little expensive?</Command>
<Command>		}</Command>
<Command>		aiPlanSetUserVariableInt(MALLOC,type * 3 + xNextBlock - 1, next, 0); // next free block is 0 for a newly created block</Command>
<Command>	} else {</Command>
<Command>		aiPlanSetUserVariableInt(MALLOC,type * 3 + xNextBlock - 1,NEXTFREE,</Command>
<Command>			aiPlanGetUserVariableInt(MALLOC,type * 3 + xNextBlock - 1,next));</Command>
<Command>	}</Command>
<Command>	aiPlanSetUserVariableBool(MALLOC,type * 3 + xDirtyBit - 1, next, true); // set dirty bit</Command>

<Command>	return(next);</Command>
<Command>}</Command>

<Command>bool mGetBool(int index = 0) {</Command>
<Command>	bool val = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mBool * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		val = aiPlanGetUserVariableBool(MALLOC, mBool * 3 + xData - 1, index);</Command>
<Command>	}</Command>
<Command>	return(val);</Command>
<Command>}</Command>

<Command>bool mSetBool(int index = 0, bool val = false) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mBool * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		success = aiPlanSetUserVariableBool(MALLOC, mBool * 3 + xData - 1, index, val);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int mNewBool(bool val = false) {</Command>
<Command>	int index = malloc(mBool);</Command>
<Command>	mSetBool(index, val);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>bool mFreeBool(int index = 0) {</Command>
<Command>	return(free(mBool, index));</Command>
<Command>}</Command>


<Command>string mGetString(int index = 0) {</Command>
<Command>	string val = "";</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mString * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		val = aiPlanGetUserVariableString(MALLOC, mString * 3 + xData - 1, index);</Command>
<Command>	}</Command>
<Command>	return(val);</Command>
<Command>}</Command>

<Command>bool mSetString(int index = 0, string val = "") {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mString * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		success = aiPlanSetUserVariableString(MALLOC, mString * 3 + xData - 1, index, val);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int mNewString(string val = "") {</Command>
<Command>	int index = malloc(mString);</Command>
<Command>	mSetString(index, val);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>bool mFreeString(int index = 0) {</Command>
<Command>	return(free(mString, index));</Command>
<Command>}</Command>

<Command>int mGetInt(int index = 0) {</Command>
<Command>	int val = -1;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mInt * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		val = aiPlanGetUserVariableInt(MALLOC, mInt * 3 + xData - 1, index);</Command>
<Command>	}</Command>
<Command>	return(val);</Command>
<Command>}</Command>

<Command>bool mSetInt(int index = 0, int val = 0) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mInt * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		success = aiPlanSetUserVariableInt(MALLOC, mInt * 3 + xData - 1, index, val);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int mNewInt(int val = 0) {</Command>
<Command>	int index = malloc(mInt);</Command>
<Command>	mSetInt(index, val);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>bool mFreeInt(int index = 0) {</Command>
<Command>	return(free(mInt, index));</Command>
<Command>}</Command>

<Command>float mGetFloat(int index = 0) {</Command>
<Command>	float val = -1;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mFloat * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		val = aiPlanGetUserVariableFloat(MALLOC, mFloat * 3 + xData - 1, index);</Command>
<Command>	}</Command>
<Command>	return(val);</Command>
<Command>}</Command>

<Command>bool mSetFloat(int index = 0, float val = 0) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mFloat * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		success = aiPlanSetUserVariableFloat(MALLOC, mFloat * 3 + xData - 1, index, val);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int mNewFloat(float val = 0) {</Command>
<Command>	int index = malloc(mFloat);</Command>
<Command>	mSetFloat(index, val);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>bool mFreeFloat(int index = 0) {</Command>
<Command>	return(free(mFloat, index));</Command>
<Command>}</Command>

<Command>vector mGetVector(int index = 0) {</Command>
<Command>	vector val = vector(-1,-1,-1);</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mVector * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		val = aiPlanGetUserVariableVector(MALLOC, mVector * 3 + xData - 1, index);</Command>
<Command>	}</Command>
<Command>	return(val);</Command>
<Command>}</Command>

<Command>bool mSetVector(int index = 0, vector val = vector(0,0,0)) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(MALLOC, mVector * 3 + xDirtyBit - 1, index)) {</Command>
<Command>		success = aiPlanSetUserVariableVector(MALLOC, mVector * 3 + xData - 1, index, val);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int mNewVector(vector val = vector(0,0,0)) {</Command>
<Command>	int index = malloc(mVector);</Command>
<Command>	mSetVector(index, val);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>bool mFreeVector(int index = 0) {</Command>
<Command>	return(free(mVector, index));</Command>
<Command>}</Command>

<Command>int xInitDatabase(string name = "", int size = 0) {</Command>
<Command>	int id = aiPlanCreate(name, 8);</Command>
<Command>	aiPlanAddUserVariableBool(id,xDirtyBit,"DirtyBit",size+1);</Command>
<Command>	aiPlanAddUserVariableInt(id,xNextBlock,"NextBlock",size+1);</Command>
<Command>	aiPlanAddUserVariableInt(id,xPrevBlock,"PrevBlock",size+1);</Command>
<Command>	aiPlanAddUserVariableInt(id,xMetadata,"Metadata",6);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mPointer,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCount,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCacheHead,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCacheCount,0);</Command>

<Command>	aiPlanSetUserVariableInt(id,xMetadata,mNextFree,size);</Command>
<Command>	aiPlanSetUserVariableInt(id,xNextBlock,0,0);</Command>
<Command><![CDATA[	for(i=1; <= size) { // connect all the free buffers together]]></Command>
<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,i,false);</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,i,i-1);</Command>
<Command>	}</Command>
<Command>	aiPlanAddUserVariableString(id,xVarNames,"VarNames",1);</Command>
<Command>	aiPlanSetUserVariableString(id,xVarNames,0,"none");</Command>
<Command>	return(id);</Command>
<Command>}</Command>

<Command>int xInitAddVar(int id = 0, string name = "", int type = 0) {</Command>
<Command>	int count = aiPlanGetNumberUserVariableValues(id,xDirtyBit);</Command>
<Command>	int index = aiPlanGetNumberUserVariableValues(id,xMetadata);</Command>
<Command>	aiPlanSetNumberUserVariableValues(id,xMetadata,index + 1,false);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,index,type);</Command>

<Command>	index = aiPlanGetNumberUserVariableValues(id,xVarNames);</Command>
<Command>	aiPlanSetNumberUserVariableValues(id,xVarNames,index+1,false);</Command>
<Command>	aiPlanSetUserVariableString(id,xVarNames,index,name);</Command>
<Command>	index = xVarNames + index;</Command>
<Command>	switch(type)</Command>
<Command>	{</Command>
<Command>		case mInt:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableInt(id,index,name,count);</Command>
<Command>		}</Command>
<Command>		case mFloat:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableFloat(id,index,name,count);</Command>
<Command>		}</Command>
<Command>		case mString:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableString(id,index,name,count);</Command>
<Command>		}</Command>
<Command>		case mVector:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableVector(id,index,name,count);</Command>
<Command>		}</Command>
<Command>		case mBool:</Command>
<Command>		{</Command>
<Command>			aiPlanAddUserVariableBool(id,index,name,count);</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>int xInitAddInt(int id = 0, string name = "", int defVal = 0) {</Command>
<Command>	int index = xInitAddVar(id,name,mInt);</Command>
<Command>	aiPlanSetUserVariableInt(id, index, 0, defVal);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>int xInitAddFloat(int id = 0, string name = "", float defVal = 0) {</Command>
<Command>	int index = xInitAddVar(id, name, mFloat);</Command>
<Command>	aiPlanSetUserVariableFloat(id, index, 0, defVal);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>int xInitAddString(int id = 0, string name = "", string defVal = "") {</Command>
<Command>	int index = xInitAddVar(id, name, mString);</Command>
<Command>	aiPlanSetUserVariableString(id, index, 0, defVal);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>int xInitAddVector(int id = 0, string name = "", vector defVal = vector(0,0,0)) {</Command>
<Command>	int index = xInitAddVar(id, name, mVector);</Command>
<Command>	aiPlanSetUserVariableVector(id, index, 0, defVal);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>int xInitAddBool(int id = 0, string name = "", bool defVal = false) {</Command>
<Command>	int index = xInitAddVar(id,name,mBool);</Command>
<Command>	aiPlanSetUserVariableBool(id, index, 0, defVal);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>void xResetValues(int id = 0, int index = -1, int stopAt = -1) {</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	if (stopAt == -1) {</Command>
<Command>		stopAt = aiPlanGetNumberUserVariableValues(id, xVarNames);</Command>
<Command>	} else {</Command>
<Command>		stopAt = stopAt - mVariableTypes;</Command>
<Command>	}</Command>
<Command><![CDATA[	for(i = 1; < stopAt) {]]></Command>
<Command>		switch(aiPlanGetUserVariableInt(id,xMetadata,mVariableTypes + i))</Command>
<Command>		{</Command>
<Command>			case mInt:</Command>
<Command>			{</Command>
<Command>				aiPlanSetUserVariableInt(id,xVarNames + i,index,aiPlanGetUserVariableInt(id,xVarNames + i,0));</Command>
<Command>			}</Command>
<Command>			case mFloat:</Command>
<Command>			{</Command>
<Command>				aiPlanSetUserVariableFloat(id,xVarNames + i,index,aiPlanGetUserVariableFloat(id,xVarNames + i,0));</Command>
<Command>			}</Command>
<Command>			case mString:</Command>
<Command>			{</Command>
<Command>				aiPlanSetUserVariableString(id,xVarNames + i,index,aiPlanGetUserVariableString(id,xVarNames + i,0));</Command>
<Command>			}</Command>
<Command>			case mVector:</Command>
<Command>			{</Command>
<Command>				aiPlanSetUserVariableVector(id,xVarNames + i,index,aiPlanGetUserVariableVector(id,xVarNames + i,0));</Command>
<Command>			}</Command>
<Command>			case mBool:</Command>
<Command>			{</Command>
<Command>				aiPlanSetUserVariableBool(id,xVarNames + i,index,aiPlanGetUserVariableBool(id,xVarNames + i,0));</Command>
<Command>			}</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>bool xSetPointer(int id = 0, int index = 0) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableBool(id,xDirtyBit,index)) {</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mPointer,index);</Command>
<Command>		success = true;</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int xAddDatabaseBlock(int id = 0, bool setPointer = false) {</Command>
<Command>	int next = aiPlanGetUserVariableInt(id,xMetadata,mNextFree);</Command>
<Command>	if (next == 0) {</Command>
<Command>		next = aiPlanGetNumberUserVariableValues(id,xDirtyBit);</Command>
<Command>		for(i=aiPlanGetNumberUserVariableValues(id,xVarNames) - 1; > 0) {</Command>
<Command>			aiPlanSetNumberUserVariableValues(id,i + xVarNames,next+1,false);</Command>
<Command>		}</Command>
<Command>		for(i=xPrevBlock; > xMetadata) {</Command>
<Command>			aiPlanSetNumberUserVariableValues(id,i,next+1,false);</Command>
<Command>		}</Command>
<Command>	} else {</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mNextFree,aiPlanGetUserVariableInt(id,xNextBlock,next));</Command>
<Command>	}</Command>
<Command>	aiPlanSetUserVariableBool(id,xDirtyBit,next,true);</Command>

<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,mCount) == 0) {</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,next,next);</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,next,next);</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mPointer,next);</Command>
<Command>	} else {</Command>
<Command>		int before = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>		int after = aiPlanGetUserVariableInt(id,xNextBlock,before);</Command>

<Command>		aiPlanSetUserVariableInt(id,xNextBlock,next,after); // next of me is after</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,next,before); // prev of me is before</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,before,next); // next of before is me</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,after,next); // prev of after is me</Command>
<Command>	}</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mNewestBlock,next);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCount, 1 + aiPlanGetUserVariableInt(id,xMetadata,mCount));</Command>
<Command>	xResetValues(id,next);</Command>
<Command>	if (setPointer) {</Command>
<Command>		xSetPointer(id, next);</Command>
<Command>	}</Command>
<Command>	return(next);</Command>
<Command>}</Command>


<Command>bool xFreeDatabaseBlock(int id = 0, int index = -1) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	if (aiPlanGetUserVariableBool(id,xDirtyBit,index)) {</Command>
<Command>		int after = aiPlanGetUserVariableInt(id,xNextBlock,index);</Command>
<Command>		int before = aiPlanGetUserVariableInt(id,xPrevBlock,index);</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,before,after); // next block of before is after</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,after,before); // prev block of after is before</Command>

<Command>		aiPlanSetUserVariableInt(id,xNextBlock,index,aiPlanGetUserVariableInt(id,xMetadata,mNextFree));</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mNextFree,index);</Command>
<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,index,false);</Command>

<Command>		if (index == aiPlanGetUserVariableInt(id,xMetadata,mPointer)) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mPointer,aiPlanGetUserVariableInt(id,xPrevBlock,index));</Command>
<Command>		}</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCount, aiPlanGetUserVariableInt(id,xMetadata,mCount) - 1);</Command>
<Command>		success = true;</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>// Detaches the block and saves it in the cache.</Command>
<Command>bool xDetachDatabaseBlock(int id = 0, int index = -1) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	if (aiPlanGetUserVariableBool(id,xDirtyBit,index)) {</Command>
<Command>		int after = aiPlanGetUserVariableInt(id,xNextBlock,index);</Command>
<Command>		int before = aiPlanGetUserVariableInt(id,xPrevBlock,index);</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,before,after); // next block of before is after</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,after,before); // prev block of after is before</Command>

<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,index,false);</Command>

<Command>		if (index == aiPlanGetUserVariableInt(id,xMetadata,mPointer)) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mPointer,before);</Command>
<Command>		}</Command>

<Command>		if (aiPlanGetUserVariableInt(id,xMetadata,mCacheCount) == 0) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xNextBlock,index,index);</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,index,index);</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mCacheHead,index);</Command>
<Command>		} else {</Command>
<Command>			before = aiPlanGetUserVariableInt(id,xMetadata,mCacheHead);</Command>
<Command>			after = aiPlanGetUserVariableInt(id,xNextBlock,before);</Command>

<Command>			aiPlanSetUserVariableInt(id,xNextBlock,index,after); // next of me is after</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,index,before); // prev of me is before</Command>
<Command>			aiPlanSetUserVariableInt(id,xNextBlock,before,index); // next of before is me</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,after,index); // prev of after is me</Command>
<Command>		}</Command>

<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCount, aiPlanGetUserVariableInt(id,xMetadata,mCount) - 1);</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCacheCount, aiPlanGetUserVariableInt(id,xMetadata,mCacheCount) + 1);</Command>
<Command>		success = true;</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>bool xRestoreDatabaseBlock(int id = 0, int index = -1) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mCacheHead);</Command>
<Command>	}</Command>
<Command>	if (aiPlanGetUserVariableBool(id,xDirtyBit,index) == false) {</Command>
<Command>		int after = aiPlanGetUserVariableInt(id,xNextBlock,index);</Command>
<Command>		int before = aiPlanGetUserVariableInt(id,xPrevBlock,index);</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,before,after); // next block of before is after</Command>
<Command>		aiPlanSetUserVariableInt(id,xPrevBlock,after,before); // prev block of after is before</Command>

<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,index,true);</Command>

<Command>		if (index == aiPlanGetUserVariableInt(id,xMetadata,mCacheHead)) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mCacheHead,aiPlanGetUserVariableInt(id,xPrevBlock,index));</Command>
<Command>		}</Command>

<Command>		if (aiPlanGetUserVariableInt(id,xMetadata,mCount) == 0) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xNextBlock,index,index);</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,index,index);</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mPointer,index);</Command>
<Command>		} else {</Command>
<Command>			before = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>			after = aiPlanGetUserVariableInt(id,xNextBlock,before);</Command>

<Command>			aiPlanSetUserVariableInt(id,xNextBlock,index,after); // next of me is after</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,index,before); // prev of me is before</Command>
<Command>			aiPlanSetUserVariableInt(id,xNextBlock,before,index); // next of before is me</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,after,index); // prev of after is me</Command>
<Command>		}</Command>

<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCount, aiPlanGetUserVariableInt(id,xMetadata,mCount) + 1);</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCacheCount, aiPlanGetUserVariableInt(id,xMetadata,mCacheCount) - 1);</Command>
<Command>		success = true;</Command>
<Command>	}</Command>

<Command>	return(success);</Command>
<Command>}</Command>

<Command>bool xRestoreCache(int id = 0) {</Command>
<Command>	bool success = false;</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,mCacheCount) > 0) {</Command>
<Command>		int pointer = aiPlanGetUserVariableInt(id,xMetadata,mCacheHead);</Command>
<Command>		for(i=aiPlanGetUserVariableInt(id,xMetadata,mCacheCount); >0) {</Command>
<Command>			aiPlanSetUserVariableBool(id,xDirtyBit,pointer,true);</Command>
<Command>			pointer = aiPlanGetUserVariableInt(id,xNextBlock,pointer);</Command>
<Command>		}</Command>
<Command>		if (aiPlanGetUserVariableInt(id,xMetadata,mCount) == 0) {</Command>
<Command>			aiPlanSetUserVariableInt(id,xMetadata,mPointer,aiPlanGetUserVariableInt(id,xMetadata,mCacheHead));</Command>
<Command>		} else {</Command>
<Command>			int before = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>			int after = aiPlanGetUserVariableInt(id,xNextBlock,before);</Command>
<Command>			int index = aiPlanGetUserVariableInt(id,xMetadata,mCacheHead);</Command>
<Command>			int next = aiPlanGetUserVariableInt(id,xPrevBlock,index); // the next of this block will be the after block</Command>

<Command>			aiPlanSetUserVariableInt(id,xNextBlock,next,after); // next of next is after</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,after,next); // prev of after is next</Command>

<Command>			aiPlanSetUserVariableInt(id,xNextBlock,before,index); // next of before is me</Command>
<Command>			aiPlanSetUserVariableInt(id,xPrevBlock,index,before); // prev of me is before</Command>
<Command>		}</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCount,</Command>
<Command>			aiPlanGetUserVariableInt(id,xMetadata,mCount) + aiPlanGetUserVariableInt(id,xMetadata,mCacheCount));</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCacheHead,0);</Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mCacheCount,0);</Command>
<Command>		success = true;</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>

<Command>int xGetNewestPointer(int id = 0) {</Command>
<Command>	return(aiPlanGetUserVariableInt(id,xMetadata,mNewestBlock));</Command>
<Command>}</Command>

<Command>int xDatabaseNext(int id = 0, bool reverse = false) {</Command>
<Command>	int pointer = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	if (reverse) {</Command>
<Command>		pointer = aiPlanGetUserVariableInt(id,xPrevBlock,pointer);</Command>
<Command>	} else {</Command>
<Command>		pointer = aiPlanGetUserVariableInt(id,xNextBlock,pointer);</Command>
<Command>	}</Command>
<Command><![CDATA[	if (aiPlanGetUserVariableBool(id,xDirtyBit,pointer) && (aiPlanGetUserVariableInt(id,xMetadata,mCount) > 0)) {]]></Command>
<Command>		aiPlanSetUserVariableInt(id,xMetadata,mPointer,pointer);</Command>
<Command>	} else {</Command>
<Command>		pointer = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>		debugLog("xDatabaseNext: " + aiPlanGetName(id) + " pointer is incorrect!");</Command>
<Command>		debugLog("xNextBlock: " + aiPlanGetUserVariableInt(id,xNextBlock,pointer));</Command>
<Command>		debugLog("Me: " + pointer);</Command>
<Command>		debugLog("xPrevblock: " + aiPlanGetUserVariableInt(id,xPrevBlock,pointer));</Command>
<Command>	}</Command>
<Command>	return(pointer);</Command>
<Command>}</Command>

<Command>void xClearDatabase(int id = 0) {</Command>
<Command>	int next = aiPlanGetUserVariableInt(id,xMetadata,mNextFree);</Command>
<Command>	int pointer = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mNextFree,aiPlanGetUserVariableInt(id,xNextBlock,pointer));</Command>
<Command>	aiPlanSetUserVariableInt(id,xNextBlock,pointer,next);</Command>

<Command><![CDATA[	for(i=0; < aiPlanGetNumberUserVariableValues(id,xDirtyBit)) {]]></Command>
<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,i,false);</Command>
<Command>	}</Command>

<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCount,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mPointer,0);</Command>
<Command>}</Command>

<Command>void xResetDatabase(int id = 0) {</Command>
<Command>	int size = aiPlanGetNumberUserVariableValues(id,xDirtyBit);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mPointer,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCount,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCacheHead,0);</Command>
<Command>	aiPlanSetUserVariableInt(id,xMetadata,mCacheCount,0);</Command>

<Command>	aiPlanSetUserVariableInt(id,xMetadata,mNextFree,size - 1);</Command>
<Command>	aiPlanSetUserVariableInt(id,xNextBlock,0,0);</Command>
<Command><![CDATA[	for(i=1; < size) { // connect all the free buffers together]]></Command>
<Command>		aiPlanSetUserVariableBool(id,xDirtyBit,i,false);</Command>
<Command>		aiPlanSetUserVariableInt(id,xNextBlock,i,i-1);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>int xGetInt(int id = 0, int data = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mInt) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetInt: " + aiPlanGetName(id) + " variable " + name + " is not an int! Type: " + type);</Command>
<Command>		return(-1); // if we are trying to get an int from the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanGetUserVariableInt(id,data,index));</Command>
<Command>}</Command>

<Command>bool xSetInt(int id = 0, int data = 0, int val = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mInt) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xSetInt: " + aiPlanGetName(id) + " variable " + name + " is not an int! Type: " + type);</Command>
<Command>		return(false); // if we are trying to set the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	bool success = aiPlanSetUserVariableInt(id,data,index,val);</Command>
<Command>	if (success == false) {</Command>
<Command>		string err = ": Could not assign value: " + val;</Command>
<Command>		debugLog("xSetInt: " + aiPlanGetName(id) + aiPlanGetUserVariableString(id,xVarNames,data - xVarNames) + err);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>


<Command>float xGetFloat(int id = 0, int data = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mFloat) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetFloat: " + aiPlanGetName(id) + " variable " + name + " is not a float! Type: " + type);</Command>
<Command>		return(-1.0); // if we are trying to get an int from the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanGetUserVariableFloat(id,data,index));</Command>
<Command>}</Command>

<Command>bool xSetFloat(int id = 0, int data = 0, float val = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mFloat) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xSetFloat: " + aiPlanGetName(id) + " variable " + name + " is not a float! Type: " + type);</Command>
<Command>		return(false); // if we are trying to set the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	bool success = aiPlanSetUserVariableFloat(id,data,index,val);</Command>
<Command>	if (success == false) {</Command>
<Command>		string err = ": Could not assign value: " + val;</Command>
<Command>		debugLog("xSetFloat: " + aiPlanGetName(id) + aiPlanGetUserVariableString(id,xVarNames,data - xVarNames) + err);</Command>
<Command>	}</Command>
<Command>	return(success);</Command>
<Command>}</Command>


<Command>string xGetString(int id = 0, int data = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mString) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetString: " + aiPlanGetName(id) + " variable " + name + " is not a string! Type: " + type);</Command>
<Command>		return(""); // if we are trying to get an int from the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanGetUserVariableString(id,data,index));</Command>
<Command>}</Command>

<Command>bool xSetString(int id = 0, int data = 0, string val = "", int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mString) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xSetString: " + aiPlanGetName(id) + " variable " + name + " is not a string! Type: " + type);</Command>
<Command>		return(false); // if we are trying to set the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanSetUserVariableString(id,data,index,val));</Command>
<Command>}</Command>


<Command>vector xGetVector(int id = 0, int data = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mVector) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetVector: " + aiPlanGetName(id) + " variable " + name + " is not a vector! Type: " + type);</Command>
<Command>		return(vector(0,0,0)); // if we are trying to get an int from the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanGetUserVariableVector(id,data,index));</Command>
<Command>}</Command>

<Command>bool xSetVector(int id = 0, int data = 0, vector val = vector(0,0,0), int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mVector) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xSetVector: " + aiPlanGetName(id) + " variable " + name + " is not a vector! Type: " + type);</Command>
<Command>		return(false); // if we are trying to set the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanSetUserVariableVector(id,data,index,val));</Command>
<Command>}</Command>


<Command>bool xGetBool(int id = 0, int data = 0, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mBool) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetBool: " + aiPlanGetName(id) + " variable " + name + " is not a bool! Type: " + type);</Command>
<Command>		return(false); // if we are trying to get an int from the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanGetUserVariableBool(id,data,index));</Command>
<Command>}</Command>

<Command>bool xSetBool(int id = 0, int data = 0, bool val = false, int index = -1) {</Command>
<Command>	if (aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes) != mBool) {</Command>
<Command>		string type = datatypeName(aiPlanGetUserVariableInt(id,xMetadata,data - xVarNames + mVariableTypes));</Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,data - xVarNames);</Command>
<Command>		debugLog("xGetBool: " + aiPlanGetName(id) + " variable " + name + " is not a bool! Type: " + type);</Command>
<Command>		return(false); // if we are trying to set the wrong datatype, stop</Command>
<Command>	}</Command>
<Command>	if (index == -1) {</Command>
<Command>		index = aiPlanGetUserVariableInt(id,xMetadata,mPointer);</Command>
<Command>	}</Command>
<Command>	return(aiPlanSetUserVariableBool(id,data,index,val));</Command>
<Command>}</Command>

<Command>int xGetDatabaseCount(int id = 0) {</Command>
<Command>	return(aiPlanGetUserVariableInt(id,xMetadata,mCount));</Command>
<Command>}</Command>

<Command>int xGetPointer(int id = 0) {</Command>
<Command>	return(aiPlanGetUserVariableInt(id,xMetadata,mPointer));</Command>
<Command>}</Command>

<Command>void xPrintAll(int id = 0, int index = 0) {</Command>
<Command><![CDATA[	trChatSend(0, "<u>" + aiPlanGetName(id) + "</u>");]]></Command>
<Command>	trChatSend(0, "size: " + xGetDatabaseCount(id));</Command>
<Command>	trChatSend(0, "pointer: " + index);</Command>
<Command><![CDATA[	for(i=1; < aiPlanGetNumberUserVariableValues(id,xVarNames)) {]]></Command>
<Command>		string name = aiPlanGetUserVariableString(id,xVarNames,i);</Command>
<Command>		int type = aiPlanGetUserVariableInt(id,xMetadata,mVariableTypes + i);</Command>
<Command>		switch(type)</Command>
<Command>		{</Command>
<Command>			case mInt:</Command>
<Command>			{</Command>
<Command>				trChatSend(0, name + ": " + aiPlanGetUserVariableInt(id,xVarNames + i,index));</Command>
<Command>			}</Command>
<Command>			case mFloat:</Command>
<Command>			{</Command>
<Command>				trChatSend(0, name + ": " + aiPlanGetUserVariableFloat(id,xVarNames + i,index));</Command>
<Command>			}</Command>
<Command>			case mString:</Command>
<Command>			{</Command>
<Command>				trChatSend(0, name + ": " + aiPlanGetUserVariableString(id,xVarNames + i,index));</Command>
<Command>			}</Command>
<Command>			case mVector:</Command>
<Command>			{</Command>
<Command>				trChatSend(0, name + ": " + aiPlanGetUserVariableVector(id,xVarNames + i,index));</Command>
<Command>			}</Command>
<Command>			case mBool:</Command>
<Command>			{</Command>
<Command>				if (aiPlanGetUserVariableBool(id,xVarNames + i,index)) {</Command>
<Command>					trChatSend(0, name + ": true");</Command>
<Command>				} else {</Command>
<Command>					trChatSend(0, name + ": false");</Command>
<Command>				}</Command>
<Command>			}</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void xUnitSelect(int id = 0, int varn = 0, bool reverse = true) {</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	trUnitSelect(""+xGetInt(id,varn), reverse);</Command>
<Command>}</Command>

<Command>void xUnitSelectByID(int db = 0, int varn = 0) {</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	trUnitSelectByID(xGetInt(db,varn));</Command>
<Command>}</Command>

<Command>rule mInitializeMemory</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	xsDisableSelf();</Command>
<Command>	aiSet("NoAI", 0);</Command>
<Command>	MALLOC = aiPlanCreate("memory",8);</Command>
<Command>	ARRAYS = aiPlanCreate("arrays",8);</Command>
<Command><![CDATA[	for(i=0; < 5) {]]></Command>
<Command>		aiPlanAddUserVariableBool(MALLOC,i * 3 + xDirtyBit - 1,"DirtyBit"+i,1);</Command>
<Command>		aiPlanAddUserVariableInt(MALLOC,i * 3 + xNextBlock - 1,"NextBlock"+i,1);</Command>
<Command>		aiPlanSetUserVariableBool(MALLOC,i * 3 + xDirtyBit - 1, NEXTFREE, true);</Command>
<Command>		aiPlanSetUserVariableInt(MALLOC,i * 3 + xNextBlock - 1, NEXTFREE, 0);</Command>
<Command>	}</Command>
<Command>	aiPlanAddUserVariableInt(MALLOC,mInt * 3 + xData - 1, "intData",1);</Command>
<Command>	aiPlanAddUserVariableFloat(MALLOC,mFloat * 3 + xData - 1, "floatData",1);</Command>
<Command>	aiPlanAddUserVariableString(MALLOC,mString * 3 + xData - 1, "stringData",1);</Command>
<Command>	aiPlanAddUserVariableVector(MALLOC,mVector * 3 + xData - 1, "vectorData",1);</Command>
<Command>	aiPlanAddUserVariableBool(MALLOC,mBool * 3 + xData - 1, "boolData",1);</Command>

<Command>	aiPlanAddUserVariableString(MALLOC,15,"datatypes",5);</Command>
<Command>	aiPlanSetUserVariableString(MALLOC,15,mInt,"Integer");</Command>
<Command>	aiPlanSetUserVariableString(MALLOC,15,mFloat,"Float");</Command>
<Command>	aiPlanSetUserVariableString(MALLOC,15,mString,"String");</Command>
<Command>	aiPlanSetUserVariableString(MALLOC,15,mVector,"Vector");</Command>
<Command>	aiPlanSetUserVariableString(MALLOC,15,mBool,"Bool");</Command>
<Command>}</Command>

<Command>void trVectorQuestVarSet(string name = "", vector QVv = vector(-1,-1,-1)) {</Command>
<Command>	if (name == "") return;</Command>
<Command>	if (trQuestVarGet("vector"+name) == 0) {</Command>
<Command>		trQuestVarSet("vector"+name, mNewVector(QVv));</Command>
<Command>	} else {</Command>
<Command>		mSetVector(1*trQuestVarGet("vector"+name),QVv);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>vector trVectorQuestVarGet(string name = "") {</Command>
<Command>	return(mGetVector(1*trQuestVarGet("vector"+name)));</Command>
<Command>}</Command>

<Command>float trVectorQuestVarGetX(string name = "") {</Command>
<Command>	return(xsVectorGetX(trVectorQuestVarGet(name)));</Command>
<Command>}</Command>

<Command>float trVectorQuestVarGetY(string name = "") {</Command>
<Command>	return(xsVectorGetY(trVectorQuestVarGet(name)));</Command>
<Command>}</Command>

<Command>float trVectorQuestVarGetZ(string name = "") {</Command>
<Command>	return(xsVectorGetZ(trVectorQuestVarGet(name)));</Command>
<Command>}</Command>

<Command>void trVectorQuestVarEcho(string name = "") {</Command>
<Command>	if (name == "") return;</Command>
<Command>	trChatSend(0, ""+name+": "+trVectorQuestVarGet(name));</Command>
<Command>}</Command>


<Command>void trStringQuestVarSet(string name = "", string value = "") {</Command>
<Command>	if (trQuestVarGet("string"+name) > 0) {</Command>
<Command>		mSetString(1*trQuestVarGet("string"+name), value);</Command>
<Command>	} else {</Command>
<Command>		trQuestVarSet("string"+name, mNewString(value));</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>string trStringQuestVarGet(string name="") {</Command>
<Command>	string val = mGetString(1*trQuestVarGet("string"+name));</Command>
<Command>	return(val);</Command>
<Command>}</Command>


<Command>bool playerIsPlaying(int p = 0) {</Command>
<Command><![CDATA[	return(kbIsPlayerHuman(p) == true && kbIsPlayerResigned(p) == false && trPlayerDefeated(p) == false);]]></Command>
<Command>}</Command>


<Command>void trUnitTeleportToVector(string v = "") {</Command>
<Command>	vector pos = trVectorQuestVarGet(v);</Command>
<Command>	trUnitTeleport(xsVectorGetX(pos),xsVectorGetY(pos),xsVectorGetZ(pos));</Command>
<Command>}</Command>

<Command>void trUnitSelectByQV(string s = "", bool reverse = true) {</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	trUnitSelect(""+1*trQuestVarGet(""+s), reverse);</Command>
<Command>}</Command>

<Command>void trVectorSetUnitPos(string v = "", string db = "", bool reverse = true) {</Command>
<Command>	trVectorQuestVarSet(v, kbGetBlockPosition(""+1*trQuestVarGet(db), reverse));</Command>
<Command>}</Command>

<Command>void trVectorSetUnitPosInt(string v = "", int val = 0, bool reverse = true) {</Command>
<Command>	trVectorQuestVarSet(v, kbGetBlockPosition(""+val, reverse));</Command>
<Command>}</Command>


<Command>void trUnitMoveToVector(string v = "", bool attack = false) {</Command>
<Command>	trUnitMoveToPoint(trVectorQuestVarGetX(v),0,trVectorQuestVarGetZ(v),-1,attack);</Command>
<Command>}</Command>

<Command>void trVectorScale(string db = "", float s = 1.0) {</Command>
<Command>	trVectorQuestVarSet(db, trVectorQuestVarGet(db) * s);</Command>
<Command>}</Command>

<Command>vector vectorSnapToGrid(vector v = vector(0,0,0)) {</Command>
<Command>	int x = xsVectorGetX(v) / 2;</Command>
<Command>	int z = xsVectorGetZ(v) / 2;</Command>
<Command>	return(xsVectorSet(x * 2 + 1,xsVectorGetY(v),z * 2 + 1));</Command>
<Command>}</Command>

<Command>void trVectorSnapToGrid(string qv = "") {</Command>
<Command>	trVectorQuestVarSet(qv, vectorSnapToGrid(trVectorQuestVarGet(qv)));</Command>
<Command>}</Command>

<Command>int iModulo(int mod = 10, int val = 0) {</Command>
<Command>	return(val - val / mod * mod);</Command>
<Command>}</Command>

<Command>float fModulo(float mod = 0, float val = 0) {</Command>
<Command>	int c = 0;</Command>
<Command>	if (val > 0) {</Command>
<Command>		c = val / mod;</Command>
<Command>	} else {</Command>
<Command>		c = val / mod - 1;</Command>
<Command>	}</Command>
<Command>	return(0.0 + val - mod * c);</Command>
<Command>}</Command>

<Command>bool getBit(int bit = 0, int val = 0) {</Command>
<Command>	val = val / xsPow(2, bit);</Command>
<Command>	return((iModulo(2, val) == 1));</Command>
<Command>}</Command>

<Command>void zUnitHeading(float a = 0) {</Command>
<Command>	trSetUnitOrientation(xsVectorSet(xsSin(a),0,xsCos(a)), xsVectorSet(0,1,0), true);</Command>
<Command>}</Command>

<Command>void zInitProtoUnitStat(string r = "", int p = 0, int f = 0, float v = 0.0) {</Command>
<Command>	trQuestVarSet("p"+p+"pf"+kbGetProtoUnitID(r)+"f"+f, v);</Command>
<Command>}</Command>

<Command>void mSetProtoUnitStat(string r = "", int p = 0, int f = 0, float v = 0.0) {</Command>
<Command>for(zsps=0; >1){}</Command>
<Command>	zsps = kbGetProtoUnitID(r);</Command>
<Command>	trModifyProtounit(r, p, f, 0.0 + v - trQuestVarGet("p"+p+"pf"+zsps+"f"+f));</Command>
<Command>	trQuestVarSet("p"+p+"pf"+zsps+"f"+f, 0.0 + v);</Command>
<Command>}</Command>

<Command>vector vectorToGrid(vector v = vector(0,0,0)) {</Command>
<Command>	return(xsVectorSet(0 + xsVectorGetX(v) / 2,xsVectorGetY(v),0 + xsVectorGetZ(v) / 2));</Command>
<Command>}</Command>

<Command>void trVectorToGrid(string from = "", string to = ""){</Command>
<Command>	trVectorQuestVarSet(to, vectorToGrid(trVectorQuestVarGet(from)));</Command>
<Command>}</Command>

<Command>vector gridToVector(vector g = vector(0,0,0)) {</Command>
<Command>	return(xsVectorSet(xsVectorGetX(g) * 2 + 1,xsVectorGetY(g),xsVectorGetZ(g) * 2 + 1));</Command>
<Command>}</Command>

<Command>void trGridToVector(string from = "", string to = "") {</Command>
<Command>	trVectorQuestVarSet(to, gridToVector(trVectorQuestVarGet(from)));</Command>
<Command>}</Command>

<Command>void trSquareVar(string qv = "") {</Command>
<Command>	trQuestVarSet(qv, xsPow(trQuestVarGet(qv), 2));</Command>
<Command>}</Command>

<Command>float distanceBetweenVectors(vector start = vector(0,0,0), vector end = vector(0,0,0), bool squared = true) {</Command>
<Command>	float xDiff = xsVectorGetX(end) - xsVectorGetX(start);</Command>
<Command>	float zDiff = xsVectorGetZ(end) - xsVectorGetZ(start);</Command>
<Command>	float dist = xDiff * xDiff + zDiff * zDiff;</Command>
<Command>	if (squared == false) {</Command>
<Command>		dist = xsSqrt(dist);</Command>
<Command>	}</Command>
<Command>	return(dist);</Command>
<Command>}</Command>

<Command>float trDistanceBetweenVectorsSquared(string start = "", string end = "") {</Command>
<Command>	return(distanceBetweenVectors(trVectorQuestVarGet(start),trVectorQuestVarGet(end)));</Command>
<Command>}</Command>

<Command>bool vectorInRectangle(vector pos = vector(0,0,0), vector bot = vector(0,0,0), vector top = vector(0,0,0)) {</Command>
<Command><![CDATA[	if (xsVectorGetX(pos) < xsVectorGetX(bot)) {]]></Command>
<Command>		return(false);</Command>
<Command>	}</Command>
<Command>	if (xsVectorGetX(pos) > xsVectorGetX(top)) {</Command>
<Command>		return(false);</Command>
<Command>	}</Command>
<Command><![CDATA[	if (xsVectorGetZ(pos) < xsVectorGetZ(bot)) {]]></Command>
<Command>		return(false);</Command>
<Command>	}</Command>
<Command>	if (xsVectorGetZ(pos) > xsVectorGetZ(top)) {</Command>
<Command>		return(false);</Command>
<Command>	}</Command>
<Command>	return(true);</Command>
<Command>}</Command>

<Command>bool trVectorInRectangle(string pos = "", string bot = "", string top = "") {</Command>
<Command>	vector tempPos = mGetVector(1*trQuestVarGet(pos));</Command>
<Command>	vector tempBot = mGetVector(1*trQuestVarGet(bot));</Command>
<Command>	vector tempTop = mGetVector(1*trQuestVarGet(top));</Command>
<Command>	return(vectorInRectangle(tempPos,tempBot,tempTop));</Command>
<Command>}</Command>

<Command>vector rotationMatrix(vector v = vector(0,0,0), float cosT = 0, float sinT = 0) {</Command>
<Command>	float x = xsVectorGetX(v);</Command>
<Command>	float z = xsVectorGetZ(v);</Command>
<Command>	vector ret = xsVectorSet(x * cosT - z * sinT, 0, x * sinT + z * cosT);</Command>
<Command>	return(ret);</Command>
<Command>}</Command>

<Command>float trDistanceBetweenVectors(string start = "", string end = "") {</Command>
<Command>	return(distanceBetweenVectors(trVectorQuestVarGet(start),trVectorQuestVarGet(end),false));</Command>
<Command>}</Command>

<Command>float distanceBetweenVectors3d(vector start = vector(0,0,0), vector end = vector(0,0,0), bool squared = true) {</Command>
<Command>	float xdiff = xsVectorGetX(start) - xsVectorGetX(end);</Command>
<Command>	float ydiff = xsVectorGetY(start) - xsVectorGetY(end);</Command>
<Command>	float zdiff = xsVectorGetZ(start) - xsVectorGetZ(end);</Command>
<Command>	float dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;</Command>
<Command>	if (squared == false) {</Command>
<Command>		dist = xsSqrt(dist);</Command>
<Command>	}</Command>
<Command>	return(dist);</Command>
<Command>}</Command>

<Command>float trDistanceBetweenVectors3d(string start = "", string end = "") {</Command>
<Command>	return(distanceBetweenVectors3d(trVectorQuestVarGet(start),trVectorQuestVarGet(end),false));</Command>
<Command>}</Command>

<Command>float unitDistanceToVector(int name = 0, vector v = vector(0,0,0), bool squared = true) {</Command>
<Command>	vector temp = kbGetBlockPosition(""+name,true);</Command>
<Command>	return(distanceBetweenVectors(temp,v,squared));</Command>
<Command>}</Command>

<Command>float trDistanceToVectorSquared(string qv = "", string v = "") {</Command>
<Command>	return(unitDistanceToVector(1*trQuestVarGet(qv),trVectorQuestVarGet(v)));</Command>
<Command>}</Command>

<Command>float trDistanceToVector(string qv = "", string v = "") {</Command>
<Command>	return(unitDistanceToVector(1*trQuestVarGet(qv),trVectorQuestVarGet(v),false));</Command>
<Command>}</Command>

<Command>vector vectorSetFromAngle(float angle = 0) {</Command>
<Command>	return(xsVectorSet(xsSin(angle), 0, xsCos(angle)));</Command>
<Command>}</Command>

<Command>void trVectorSetFromAngle(string qv = "", float angle = 0) {</Command>
<Command>	trVectorQuestVarSet(qv,xsVectorSet(xsSin(angle), 0, xsCos(angle)));</Command>
<Command>}</Command>

<Command>float angleBetweenVectors(vector from = vector(0,0,0), vector to = vector(0,0,0)) {</Command>
<Command>	float a = xsVectorGetX(to) - xsVectorGetX(from);</Command>
<Command>	a = a / (xsVectorGetZ(to) - xsVectorGetZ(from));</Command>
<Command>	a = xsAtan(a);</Command>
<Command>	if (xsVectorGetZ(from) > xsVectorGetZ(to)) {</Command>
<Command>		if (xsVectorGetX(from) > xsVectorGetX(to)) {</Command>
<Command>			a = a - PI;</Command>
<Command>		} else {</Command>
<Command>			a = a + PI;</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(a);</Command>
<Command>}</Command>

<Command>float trAngleBetweenVectors(string from = "", string to = "") {</Command>
<Command>	return(angleBetweenVectors(trVectorQuestVarGet(from),trVectorQuestVarGet(to)));</Command>
<Command>}</Command>

<Command>float angleOfVector(vector dir = vector(0,0,0)) {</Command>
<Command>	float a = xsVectorGetX(dir) / xsVectorGetZ(dir);</Command>
<Command>	a = xsAtan(a);</Command>
<Command>	if (0.0 > xsVectorGetZ(dir)) {</Command>
<Command>		if (0.0 > xsVectorGetX(dir)) {</Command>
<Command>			a = a - PI;</Command>
<Command>		} else {</Command>
<Command>			a = a + PI;</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(a);</Command>
<Command>}</Command>

<Command>float trAngleOfVector(string v = "") {</Command>
<Command>	return(angleOfVector(trVectorQuestVarGet(v)));</Command>
<Command>}</Command>

<Command>vector getUnitVector(vector start = vector(0,0,0), vector end = vector(0,0,0), float mod = 1.0) {</Command>
<Command>	float xdiff = xsVectorGetX(end) - xsVectorGetX(start);</Command>
<Command>	float zdiff = xsVectorGetZ(end) - xsVectorGetZ(start);</Command>
<Command>	float dist = xsSqrt(xdiff * xdiff + zdiff * zdiff);</Command>
<Command>	vector ret = vector(1,0,0);</Command>
<Command>	if (dist > 0) {</Command>
<Command>		ret = xsVectorSet(xdiff / dist * mod, 0, zdiff / dist * mod);</Command>
<Command>	}</Command>
<Command>	return(ret);</Command>
<Command>}</Command>

<Command>vector trGetUnitVector(string start = "", string end = "", float mod = 1.0) {</Command>
<Command>	return(getUnitVector(trVectorQuestVarGet(start),trVectorQuestVarGet(end),mod));</Command>
<Command>}</Command>

<Command>vector getUnitVector3d(vector start = vector(0,0,0), vector end = vector(0,0,0), float mod = 1.0) {</Command>
<Command>	float xdiff = xsVectorGetX(end) - xsVectorGetX(start);</Command>
<Command>	float ydiff = xsVectorGetY(end) - xsVectorGetY(start);</Command>
<Command>	float zdiff = xsVectorGetZ(end) - xsVectorGetZ(start);</Command>
<Command>	float dist = xsSqrt(xdiff * xdiff + ydiff * ydiff + zdiff * zdiff);</Command>
<Command>	vector ret = vector(0,1,0);</Command>
<Command>	if (dist > 0) {</Command>
<Command>		ret = xsVectorSet(xdiff / dist * mod, ydiff / dist * mod, zdiff / dist * mod);</Command>
<Command>	}</Command>
<Command>	return(ret);</Command>
<Command>}</Command>

<Command>vector trGetUnitVector3d(string start = "", string end = "", float mod = 1.0) {</Command>
<Command>	return(getUnitVector3d(trVectorQuestVarGet(start),trVectorQuestVarGet(end),mod));</Command>
<Command>}</Command>

<Command>vector crossProduct(vector a = vector(0,0,0), vector b = vector(0,0,0)) {</Command>
<Command>	float x = xsVectorGetY(a) * xsVectorGetZ(b) - xsVectorGetZ(a) * xsVectorGetY(b);</Command>
<Command>	float y = xsVectorGetZ(a) * xsVectorGetX(b) - xsVectorGetX(a) * xsVectorGetZ(b);</Command>
<Command>	float z = xsVectorGetX(a) * xsVectorGetY(b) - xsVectorGetY(a) * xsVectorGetX(b);</Command>
<Command>	vector ret = xsVectorSet(x, y, z);</Command>
<Command>	return(ret);</Command>
<Command>}</Command>

<Command>float dotProduct(vector a = vector(0,0,0), vector b = vector(0,0,0)) {</Command>
<Command>	return(xsVectorGetX(a) * xsVectorGetX(b) + xsVectorGetZ(a) * xsVectorGetZ(b));</Command>
<Command>}</Command>

<Command>bool terrainIsType(vector v = vector(0,0,0), int type = 0, int subtype = 0) {</Command>
<Command>	bool isType = trGetTerrainType(xsVectorGetX(v),xsVectorGetZ(v)) == type;</Command>
<Command>	isType = trGetTerrainSubType(xsVectorGetX(v),xsVectorGetZ(v)) == subtype;</Command>
<Command>	return(isType);</Command>
<Command>}</Command>

<Command>bool trTerrainIsType(string qv = "", int type = 0, int subtype = 0) {</Command>
<Command>	return(terrainIsType(trVectorQuestVarGet(qv),type,subtype));</Command>
<Command>}</Command>

<Command>void modularCounterInit(string name = "", int size = 0) {</Command>
<Command>	trQuestVarSet("counter" + name + "size", size);</Command>
<Command>	trQuestVarSet("counter" + name + "pointer", 1);</Command>
<Command>	trQuestVarSet(name, 1);</Command>
<Command>}</Command>

<Command>int modularCounterNext(string name = "") {</Command>
<Command>	trQuestVarSet("counter" + name + "pointer", 1 + trQuestVarGet("counter" + name + "pointer"));</Command>
<Command>	if (trQuestVarGet("counter" + name + "pointer") > trQuestVarGet("counter" + name + "size")) {</Command>
<Command>		trQuestVarSet("counter" + name + "pointer", 1);</Command>
<Command>	}</Command>
<Command>	trQuestVarSet(name, trQuestVarGet("counter"+name+"pointer"));</Command>
<Command>	return(0 + trQuestVarGet("counter" + name + "pointer"));</Command>
<Command>}</Command>

<Command>int peekModularCounterNext(string name = "") {</Command>
<Command>	trQuestVarSet("counter" + name + "fake", 1 + trQuestVarGet("counter" + name + "pointer"));</Command>
<Command>	if (trQuestVarGet("counter" + name + "fake") >= trQuestVarGet("counter" + name + "size")) {</Command>
<Command>		trQuestVarSet("counter" + name + "fake", 1);</Command>
<Command>	}</Command>
<Command>	return(0 + trQuestVarGet("counter" + name + "fake"));</Command>
<Command>}</Command>

<Command>bool yDatabaseCreateIfNull(string dbname = "", int count = 0) {</Command>
<Command>	bool created = false;</Command>
<Command>	if (trQuestVarGet("database"+dbname) == 0) {</Command>
<Command><![CDATA[		if (count < 0) {]]></Command>
<Command>			count = 0;</Command>
<Command>		}</Command>
<Command>		trQuestVarSet("database"+dbname, xInitDatabase(dbname, count));</Command>
<Command>		created = true;</Command>
<Command>	}</Command>
<Command>	return(created);</Command>
<Command>}</Command>

<Command>bool yVariableExists(string dbname = "", string varname = "") {</Command>
<Command>	int db = trQuestVarGet("database"+dbname);</Command>
<Command>	int var = trQuestVarGet("database"+dbname+varname);</Command>
<Command>	return(db * var > 0);</Command>
<Command>}</Command>

<Command>float yGetVarAtIndex(string db = "", string var = "", int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		return(xGetFloat(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),index));</Command>
<Command>	} else {</Command>
<Command>		return(0);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>float yGetVar(string db = "", string var = "") {</Command>
<Command>	return(yGetVarAtIndex(db, var, -1));</Command>
<Command>}</Command>

<Command>string yGetStringAtIndex(string db = "", string var = "", int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		return(xGetString(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),index));</Command>
<Command>	} else {</Command>
<Command>		return("");</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>string yGetString(string db = "", string var = "") {</Command>
<Command>	return(yGetStringAtIndex(db, var, -1));</Command>
<Command>}</Command>

<Command>vector yGetVectorAtIndex(string db = "", string var = "", int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		return(xGetVector(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),index));</Command>
<Command>	} else {</Command>
<Command>		return(vector(0,0,0));</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>vector yGetVector(string db = "", string var = "") {</Command>
<Command>	return(yGetVectorAtIndex(db, var, -1));</Command>
<Command>}</Command>

<Command>void ySetVarAtIndex(string db = "", string var = "", float val = 0, int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		xSetFloat(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	} else {</Command>
<Command>		yDatabaseCreateIfNull(db, index);</Command>
<Command>		trQuestVarSet("database"+db+var, xInitAddFloat(1*trQuestVarGet("database"+db),var));</Command>
<Command>		xSetFloat(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void ySetVar(string db = "", string var = "", float val = 0) {</Command>
<Command>	ySetVarAtIndex(db, var, val, -1);</Command>
<Command>}</Command>

<Command>void ySetStringAtIndex(string db = "", string var = "", string val = "", int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		xSetString(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	} else {</Command>
<Command>		yDatabaseCreateIfNull(db, index);</Command>
<Command>		trQuestVarSet("database"+db+var, xInitAddFloat(1*trQuestVarGet("database"+db),var));</Command>
<Command>		xSetString(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void ySetString(string db = "", string var = "", string val = "") {</Command>
<Command>	ySetStringAtIndex(db, var, val, -1);</Command>
<Command>}</Command>

<Command>void ySetVectorAtIndex(string db = "", string var = "", vector val = vector(0,0,0), int index = 0) {</Command>
<Command>	if (yVariableExists(db, var)) {</Command>
<Command>		xSetVector(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	} else {</Command>
<Command>		yDatabaseCreateIfNull(db, index);</Command>
<Command>		trQuestVarSet("database"+db+var, xInitAddFloat(1*trQuestVarGet("database"+db),var));</Command>
<Command>		xSetVector(1*trQuestVarGet("database"+db),1*trQuestVarGet("database"+db+var),val,index);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void ySetVector(string db = "", string var = "", vector val = vector(0,0,0)) {</Command>
<Command>	ySetVectorAtIndex(db, var, val, -1);</Command>
<Command>}</Command>

<Command>int yDatabaseNext(string db = "", bool select = false, bool reverse = false) {</Command>
<Command>	xDatabaseNext(1*trQuestVarGet("database"+db), reverse);</Command>
<Command>	int u = yGetVar(db, "unitName");</Command>
<Command>	trQuestVarSet(db, u);</Command>
<Command>	if (select) {</Command>
<Command>		trUnitSelectClear();</Command>
<Command>		trUnitSelect(""+u, true);</Command>
<Command>		return(kbGetBlockID(""+u, true));</Command>
<Command>	} else {</Command>
<Command>		return(u);</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void yRemoveFromDatabase(string db = "") {</Command>
<Command>	xFreeDatabaseBlock(1*trQuestVarGet("database"+db));</Command>
<Command>}</Command>

<Command>int yGetNewestPointer(string db = "") {</Command>
<Command>	return(xGetNewestPointer(1*trQuestVarGet("database"+db)));</Command>
<Command>}</Command>

<Command>void yAddUpdateVar(string db = "", string var = "", float val = 0) {</Command>
<Command>	ySetVarAtIndex(db, var, val, yGetNewestPointer(db));</Command>
<Command>}</Command>

<Command>void yAddUpdateString(string db = "", string var = "", string val = "") {</Command>
<Command>	ySetStringAtIndex(db, var, val, yGetNewestPointer(db));</Command>
<Command>}</Command>

<Command>void yAddUpdateVector(string db = "", string var = "", vector val = vector(0,0,0)) {</Command>
<Command>	ySetVectorAtIndex(db, var, val, yGetNewestPointer(db));</Command>
<Command>}</Command>

<Command>int yAddToDatabase(string db = "", string val = "") {</Command>
<Command>	yDatabaseCreateIfNull(db);</Command>
<Command>	int id = trQuestVarGet("database"+db);</Command>
<Command>	int next = xAddDatabaseBlock(id);</Command>
<Command>	yAddUpdateVar(db, "unitName", trQuestVarGet(val));</Command>
<Command>	return(next);</Command>
<Command>}</Command>

<Command>int yGetPointer(string db = "") {</Command>
<Command>	return(xGetPointer(1*trQuestVarGet("database"+db)));</Command>
<Command>}</Command>

<Command>bool ySetPointer(string db = "", int index = 0) {</Command>
<Command>	bool safe = xSetPointer(1*trQuestVarGet("database"+db), index);</Command>
<Command>	if (safe) {</Command>
<Command>		trQuestVarSet(db, yGetVar(db, "unitName"));</Command>
<Command>	}</Command>
<Command>	return(safe);</Command>
<Command>}</Command>


<Command>int yGetDatabaseCount(string db = "") {</Command>
<Command>	return(xGetDatabaseCount(1*trQuestVarGet("database"+db)));</Command>
<Command>}</Command>

<Command>int yGetUnitAtIndex(string db = "", int index = 0) {</Command>
<Command>	return(1*yGetVarAtIndex(db, "unitName", index));</Command>
<Command>}</Command>

<Command>void ySetUnitAtIndex(string db = "", int index = 0, int value = 0) {</Command>
<Command>	ySetVarAtIndex(db, "unitName", value, index);</Command>
<Command>}</Command>

<Command>void ySetUnit(string db = "", int value = 0) {</Command>
<Command>	ySetVar(db, "unitName", value);</Command>
<Command>}</Command>

<Command>void yClearDatabase(string db = "") {</Command>
<Command>	xClearDatabase(1*trQuestVarGet("database"+db));</Command>
<Command>}</Command>


<Command>int yFindLatestReverse(string qv = "", string proto = "", int p = 0) {</Command>
<Command>	int id = kbGetProtoUnitID(proto);</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	for(x=trGetNextUnitScenarioNameNumber(); >trQuestVarGet(qv)) {</Command>
<Command>		int i = kbGetBlockID(""+x, true);</Command>
<Command>		if (kbGetUnitBaseTypeID(i) == id) {</Command>
<Command>			trUnitSelectClear();</Command>
<Command>			trUnitSelectByID(i);</Command>
<Command>			if (trUnitIsOwnedBy(p)) {</Command>
<Command>				trQuestVarSet(qv, x);</Command>
<Command>				return(i);</Command>
<Command>			}</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(-1);</Command>
<Command>}</Command>

<Command>int yFindLatest(string qv = "", string proto = "", int p = 0) {</Command>
<Command>	int id = kbGetProtoUnitID(proto);</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	int next = trGetNextUnitScenarioNameNumber() - 1;</Command>
<Command>	int current = trQuestVarGet(qv);</Command>
<Command>	while(next > current) {</Command>
<Command>		current = current + 1;</Command>
<Command>		int i = kbGetBlockID(""+current, true);</Command>
<Command>		if (kbGetUnitBaseTypeID(i) == id) {</Command>
<Command>			trUnitSelectClear();</Command>
<Command>			trUnitSelectByID(i);</Command>
<Command>			if (trUnitIsOwnedBy(p)) {</Command>
<Command>				trQuestVarSet(qv, current);</Command>
<Command>				return(i);</Command>
<Command>			}</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	return(-1);</Command>
<Command>}</Command>

<Command>// Selects the player unit</Command>
<Command>void selectPlayer() {</Command>
<Command>	trUnitSelectClear();</Command>
<Command>	trUnitSelectByQV("player");</Command>
<Command>}</Command>

<Command>void spawnPlayer(vector pos = vector(0,0,0), int heading = 0) {</Command>
<Command>	selectPlayer();</Command>
<Command>	trUnitTeleport(xsVectorGetX(pos),0,xsVectorGetZ(pos));</Command>
<Command>	trUnitSetHeading(heading);</Command>
<Command>	// may need additional functionality</Command>
<Command>}</Command>

<Command>void displayMapName(string name = "") {</Command>
<Command>	trOverlayText(name, 5.0, -1, -1, -1);</Command>
<Command>}</Command>
<Command>const int GLOBAL_DATA = 4;</Command>
<Command>const int LOCAL_DATA = 14;</Command>

<Command>int dLocalData = 0;</Command>
<Command>int xLocalDataSize = 0;</Command>
<Command>int xLocalDataSlot = 0;</Command>
<Command>int xLocalDataName = 0;</Command>

<Command>int localDataArray = 0; // an array to temporarily store the slot data in memory</Command>

<Command>void updateBirthday() {</Command>
<Command>	int birthday = 0;</Command>
<Command>	int currentdata = 0;</Command>
<Command>	// check the birthday of every map</Command>
<Command><![CDATA[	for(i=11; <= 99) {]]></Command>
<Command>		currentdata = trGetScenarioUserData(0, "CommunityRPG\crpg"+i+".scx");</Command>
<Command>		if (currentdata > birthday) {</Command>
<Command>			birthday = currentdata;</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	// also check the birthday of map 0</Command>
<Command>	currentdata = trGetScenarioUserData(0, "CommunityRPG\crpg0.scx");</Command>
<Command>	if (currentdata > birthday) {</Command>
<Command>		birthday = currentdata;</Command>
<Command>	}</Command>
<Command>	// look at me. I'm the birthday now</Command>
<Command>	trSetCurrentScenarioUserData(0, birthday + 1);</Command>
<Command>}</Command>

<Command>void saveAllData() {</Command>
<Command>	xsSetContextPlayer(0);</Command>
<Command>	int currentdata = 0;</Command>
<Command>	int slot = 0;</Command>

<Command>	// Find the highest birthday number and set our birthday to that +1</Command>
<Command>	updateBirthday();</Command>

<Command>	// save the data</Command>
<Command><![CDATA[	for(i=1; < 16) {]]></Command>
<Command>		// make all data 0 in preparation for updates</Command>
<Command>		zSetInt(localDataArray, i, 0);</Command>
<Command>	}</Command>
<Command>	// read data from the various quest vars in backwards order</Command>
<Command>	xSetPointer(dLocalData, 1);</Command>
<Command>	for(i=xGetDatabaseCount(dLocalData); >0) {</Command>
<Command>		debugLog(xGetString(dLocalData, xLocalDataName));</Command>
<Command>		// read the data in the quest var</Command>
<Command>		slot = xGetInt(dLocalData, xLocalDataSlot);</Command>
<Command>		currentdata = trQuestVarGet(xGetString(dLocalData, xLocalDataName));</Command>

<Command>		// floor and ceiling the data so it fits in the data range</Command>
<Command>		currentdata = xsMax(0, currentdata);</Command>
<Command>		currentdata = xsMin(currentdata, xGetInt(dLocalData, xLocalDataSize) - 1);</Command>

<Command>		// shift the slot data over and insert our data</Command>
<Command>		zSetInt(localDataArray, slot, zGetInt(localDataArray, slot) * xGetInt(dLocalData, xLocalDataSize) + currentdata);</Command>

<Command>		xDatabaseNext(dLocalData, true); // database search is backwards this time</Command>
<Command>	}</Command>
<Command>	// save all the data into the slots</Command>
<Command><![CDATA[	for(i=1; < 16) {]]></Command>
<Command>		trSetCurrentScenarioUserData(i, zGetInt(localDataArray, i));</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>// Reads data from the specified map</Command>
<Command>void loadAllData(int index = 0) {</Command>
<Command>	xsSetContextPlayer(0);</Command>
<Command>	string mapName = "CommunityRPG\crpg" + index + ".scx"; // this is the map that we will pull data from</Command>
<Command>	int currentdata = 0;</Command>
<Command>	int slot = 0;</Command>

<Command>	// load global data</Command>
<Command><![CDATA[	for(i=1; < LOCAL_DATA) {]]></Command>
<Command>		// load all the raw global data into the array</Command>
<Command>		zSetInt(localDataArray, i, trGetScenarioUserData(i, mapName));</Command>
<Command>	}</Command>
<Command>	// load local data</Command>
<Command>	if (trGetScenarioUserData(0, "CommunityRPG\crpg0.scx") > trGetScenarioUserData(0)) {</Command>
<Command>		// if a new game was started, wipe local data</Command>
<Command><![CDATA[		for(i=LOCAL_DATA; < 16) {]]></Command>
<Command>			trSetCurrentScenarioUserData(i, 0);</Command>
<Command>			zSetInt(localDataArray, i, 0);</Command>
<Command>		}</Command>
<Command>	} else {</Command>
<Command><![CDATA[		for(i=LOCAL_DATA; < 16) {]]></Command>
<Command>			// load all the raw local data into the array</Command>
<Command>			zSetInt(localDataArray, i, trGetScenarioUserData(i));</Command>
<Command>		}</Command>
<Command>	}</Command>

<Command>	xSetPointer(dLocalData, 1);</Command>
<Command>	// turn all the data into quest vars by traversing forwards</Command>
<Command>	for(i=xGetDatabaseCount(dLocalData); >0) {</Command>
<Command>		xDatabaseNext(dLocalData);</Command>
<Command>		debugLog(xGetString(dLocalData, xLocalDataName));</Command>
<Command>		// get the data from the slot</Command>
<Command>		slot = xGetInt(dLocalData, xLocalDataSlot);</Command>
<Command>		currentdata = zGetInt(localDataArray, slot);</Command>

<Command>		// read the data segment</Command>
<Command>		trQuestVarSet(xGetString(dLocalData, xLocalDataName), iModulo(xGetInt(dLocalData, xLocalDataSize), currentdata));</Command>

<Command>		// remove the data segment and continue</Command>
<Command>		zSetInt(localDataArray, slot, currentdata / xGetInt(dLocalData, xLocalDataSize));</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>void addSavedData(string varName = "", int slot = 14, int size = 1) {</Command>
<Command>	xAddDatabaseBlock(dLocalData, true);</Command>
<Command>	xSetString(dLocalData, xLocalDataName, varName);</Command>
<Command>	xSetInt(dLocalData, xLocalDataSize, size);</Command>
<Command>	xSetInt(dLocalData, xLocalDataSlot, slot);</Command>
<Command>}</Command>

<Command>rule ACTIVE_setup_local_data</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	dLocalData = xInitDatabase("localDataSegments");</Command>
<Command>	xLocalDataSize = xInitAddInt(dLocalData, "size");</Command>
<Command>	xLocalDataSlot = xInitAddInt(dLocalData, "slot");</Command>
<Command>	xLocalDataName = xInitAddString(dLocalData, "name");</Command>

<Command>	localDataArray = zNewArray(mInt, 16, "localData");</Command>




<Command>	addSavedData("exampleHealth", 3, 1000);</Command>
<Command>	addSavedData("exampleAttack", 3, 100);</Command>
<Command>	addSavedData("exampleQuest", 3, 4);</Command>




<Command>	xsDisableSelf();</Command>
<Command>}</Command>
<Command>int dTravelEntrances = 0;</Command>

<Command>int xTravelEntrancePos = 0;</Command>
<Command>int xTravelEntranceIndex = 0;</Command>
<Command>int xTravelEntranceName = 0;</Command>
<Command>int xTravelEntranceRadius = 0;</Command>
<Command>int xTravelEntranceActive = 0;</Command>
<Command>int xTravelEntranceHeading = 0;</Command>

<Command>// sets up a map entrance and adds it to the dTravelEntrances database</Command>
<Command>void initializeMapEntrance(vector pos = vector(0,0,0), int destIndex = 0, string destName = "", float radius = 0, int heading = 0) {</Command>
<Command>	xAddDatabaseBlock(dTravelEntrances, true);</Command>
<Command>	xSetVector(dTravelEntrances, xTravelEntrancePos, pos);</Command>
<Command>	xSetInt(dTravelEntrances, xTravelEntranceIndex, destIndex);</Command>
<Command>	xSetString(dTravelEntrances, xTravelEntranceName, destName);</Command>
<Command>	xSetFloat(dTravelEntrances, xTravelEntranceRadius, xsPow(radius, 2)); // we square the radius so distance calcs are easier later</Command>
<Command>	xSetBool(dTravelEntrances, xTravelEntranceActive, true); // set to true because the player will spawn on top of one of the entrances</Command>
<Command>	xSetInt(dTravelEntrances, xTravelEntranceHeading, heading);</Command>
<Command>	trEventSetHandler(100000 + destIndex, "travelTo");</Command>
<Command>}</Command>


<Command>void travelTo(int dest = 0) {</Command>
<Command>	xsEnableRule("travel_to_other_map");</Command>
<Command>	trQuestVarSet("travelTime", trTimeMS() + 1000);</Command>
<Command>	trQuestVarSet("travelDestination", dest - 100000);</Command>
<Command>	trUIFadeToColor(0,0,0,1000,0,true);</Command>
<Command>	saveAllData();</Command>
<Command>}</Command>

<Command>// Finds the neighbor that the player came from at the start of the map</Command>
<Command>int findMostRecentNeighbor() {</Command>
<Command>	int index = 0;</Command>
<Command>	int birthday = -1;</Command>
<Command>	int current = 0;</Command>
<Command>	for(i=xGetDatabaseCount(dTravelEntrances); >0) {</Command>
<Command>		xDatabaseNext(dTravelEntrances);</Command>
<Command>		current = trGetScenarioUserData(0, "CommunityRPG\crpg" + xGetInt(dTravelEntrances, xTravelEntranceIndex) + ".scx");</Command>
<Command>		if (current > birthday) {</Command>
<Command>			birthday = current;</Command>
<Command>			index = xGetInt(dTravelEntrances, xTravelEntranceIndex); // save the destination index</Command>
<Command>		}</Command>
<Command>	}</Command>
<Command>	trQuestVarSet("enteredFrom", index);</Command>
<Command>	debugLog("Came from " + index);</Command>
<Command>	debugLog("Birthday is " + birthday);</Command>
<Command>	trSetCurrentScenarioUserData(0, birthday);</Command>
<Command>	return(index);</Command>
<Command>}</Command>

<Command>void enterMap() {</Command>
<Command>	if (xGetDatabaseCount(dTravelEntrances) > 0) {</Command>
<Command>		// spawn the player at the entrance that they came from</Command>
<Command>		for(i=xGetDatabaseCount(dTravelEntrances); >0) {</Command>
<Command>			xDatabaseNext(dTravelEntrances);</Command>
<Command>			if (xGetInt(dTravelEntrances, xTravelEntranceIndex) == trQuestVarGet("enteredFrom")) {</Command>
<Command>				spawnPlayer(xGetVector(dTravelEntrances, xTravelEntrancePos), xGetInt(dTravelEntrances, xTravelEntranceHeading));</Command>
<Command>				break;</Command>
<Command>			}</Command>
<Command>		}</Command>
<Command>		// TODO: Damage the player based on their current health</Command>

<Command>		// Start checking the entrances</Command>
<Command>		trDelayedRuleActivation("check_travel_entrances");</Command>
<Command>	}</Command>
<Command>}</Command>


<Command>rule travel_to_other_map</Command>
<Command>inactive</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	if (trTimeMS() > trQuestVarGet("travelTime")) {</Command>
<Command>		trGameLoadScenario("CommunityRPG\crpg" + 1*trQuestVarGet("travelDestination") + ".scx");</Command>
<Command>	}</Command>
<Command>}</Command>

<Command>rule ACTIVE_setup_travel_entrances</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	dTravelEntrances = xInitDatabase("travelEntrances");</Command>
<Command>	xTravelEntrancePos = xInitAddVector(dTravelEntrances, "pos");</Command>
<Command>	xTravelEntranceIndex = xInitAddInt(dTravelEntrances, "dest");</Command>
<Command>	xTravelEntranceName = xInitAddString(dTravelEntrances, "name");</Command>
<Command>	xTravelEntranceRadius = xInitAddFloat(dTravelEntrances, "radius");</Command>
<Command>	xTravelEntranceActive = xInitAddBool(dTravelEntrances, "active");</Command>
<Command>	xTravelEntranceHeading = xInitAddInt(dTravelEntrances, "heading");</Command>

<Command>	xsDisableSelf();</Command>
<Command>}</Command>


<Command>rule check_travel_entrances</Command>
<Command>inactive</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	if (trTime() > cActivationTime) {</Command>
<Command>		if (xGetDatabaseCount(dTravelEntrances) > 0) {</Command>
<Command>			xDatabaseNext(dTravelEntrances);</Command>
<Command>			// if the player is within the radius of this entrance</Command>
<Command><![CDATA[			if (unitDistanceToVector(1*trQuestVarGet("player"), xGetVector(dTravelEntrances, xTravelEntrancePos)) < xGetFloat(dTravelEntrances, xTravelEntranceRadius)) {]]></Command>
<Command>				// if the player just entered, we give them a choice dialog</Command>
<Command>				if (xGetBool(dTravelEntrances, xTravelEntranceActive) == false) {</Command>
<Command>					xSetBool(dTravelEntrances, xTravelEntranceActive, true);</Command>
<Command>					trShowChoiceDialog("Travel to " + xGetString(dTravelEntrances, xTravelEntranceName) + "?",</Command>
<Command>						"Yes", 100000 + xGetInt(dTravelEntrances, xTravelEntranceIndex),</Command>
<Command>						"No",-1);</Command>
<Command>				}</Command>
<Command>			} else {</Command>
<Command>				// otherwise, set the entrance to inactive</Command>
<Command>				xSetBool(dTravelEntrances, xTravelEntranceActive, false);</Command>
<Command>			}</Command>

<Command>		}</Command>
<Command>	}</Command>
<Command>}</Command>
<Command>rule intro_00</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>runImmediately</Command>
<Command>{</Command>
<Command>	trUIFadeToColor(0,0,0,0,0,true);</Command>

<Command>	trDelayedRuleActivation("intro_01");</Command>
<Command>	xsDisableSelf();</Command>
<Command>}</Command>

<Command>rule intro_01</Command>
<Command>inactive</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>	saveAllData();</Command>
<Command>	trQuestVarSet("travelDestination", 11);</Command>
<Command>	xsEnableRule("travel_to_other_map");</Command>
<Command>	xsDisableSelf();</Command>
<Command>}</Command>
<Command>rule zenowashereagain</Command>
<Command>active</Command>
<Command>highFrequency</Command>
<Command>{</Command>
<Command>if(true) {</Command>
<Command>xsDisableSelf();</Command>
</Effect>
</Effects>
</trigger>